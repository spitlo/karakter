#!/usr/bin/env bash
# shellcheck disable=SC2034
set -e

# Colors
BLUE='\033[1;34m'
BROWN='\033[0;33m'
GREEN='\033[1;32m'
NC='\033[0m'
YELLOW='\033[1;33m'

# Defaults
OBFUSCATION_LO="10"
OBFUSCATION_MD="50"
OBFUSCATION_HI="100"
OBFUSCATION_CHANCE="$OBFUSCATION_MD"

USAGE="
${BROWN}Usage${NC}: $0 [ARGUMENTS] [FILE|STRING]
Add a little flair to your text by substituting visually similar characters for your ordinary a-z and A-Z characters.
There are three ways to input text:
  ${GREEN}1${NC}) Pipe text to this script
  ${GREEN}2${NC}) Supply a file as argument
  ${GREEN}3${NC}) Add word or words as arguments.
     Due to how we do argument parsing, this wont’t work for the words 'lo', 'md' and 'hi'.
${BROWN}Arguments${NC}:
  [lo|md|hi]      Level of obfuscation.
                  Defaults to 'md', medium.
"
HELP="
${BROWN}Usage examples${NC}:
  Highly obfuscate text from a file on your filesystem:
  ${BLUE}cat a_tale_of_two_cities.txt | bash/karakter hi${NC}
"

# Create alternatives for most A-Z and a-z
A="ĄΑΔΛЉАд▲"
B="8"
C="©"
D="ĎĐ"
E="єξΣΞ3€"
F=""
G=""
H="њнЂ"
I="Ϊ1"
J=""
K="ќк"
L=""
M="м"
N="ѝйи"
O="фθ0"
P=""
Q=""
R="яŔ®"
S="Ș5"
T="┬†ṪтȚŤ"
U=""
V=""
W="Ŵ"
X="χ"
Y="Ų¥"
Z=""

a="ąάαаą@ª"
b="ъьвБ6"
c="¢"
d="đď"
e="єё"
f=""
g="9"
h="ћђ"
i="ї"
j=""
k=""
l="1"
m=""
n="η"
o="фоº●"
p=""
q=""
r="ѓг"
s="ș"
t="ṫțł"
u=""
v="▼"
w="шώŵ"
x="ж×"
y="џψ"
z=""

function handle_character() {
  character="$1"
  case "$character" in
    "")
      # Don’t ask me why, but spaces come through as ""
      echo -n " "
      ;;
    [a-zA-Z])
      # If a-z or A-Z, find an alternative character, but first test against
      # obfuscation chance to se if we should bail early
      random_number=$((RANDOM % 100))
      if [ "$random_number" -gt "$OBFUSCATION_CHANCE" ]; then
        echo -n "$character"
      else
        # Try to put the string from <character> variable into a temp variable
        temp_characters="${!character}"
        if [ -n "$temp_characters" ]; then
          # If we found a string of alternative characters, pick one at random and print
          special_character="${temp_characters:$((RANDOM % ${#temp_characters})):1}"
          echo -n "$special_character"
        else
          # If not, just print the original character
          echo -n "$character"
        fi
      fi
      ;;
    *)
      # This is one of the characters we don’t transform, just print it
      echo -n "$character"
      ;;
  esac
}

argument=""

# Handle args
for arg in "$@"; do
  if [ "$arg" = "lo" ] || [ "$arg" = "md" ] || [ "$arg" = "hi" ]; then
    case "$arg" in
      "lo")
        OBFUSCATION_CHANCE="$OBFUSCATION_LO"
        ;;
      "md")
        OBFUSCATION_CHANCE="$OBFUSCATION_MD"
        ;;
      *)
        OBFUSCATION_CHANCE="$OBFUSCATION_HI"
        ;;
    esac
  elif [ "$arg" = "help" ] || [ "$arg" = "--help" ] || [ "$arg" = "-h" ]; then
    echo -e "$USAGE$HELP"
    exit 0
  else
    # Adding this to existing string instead of simply setting it allows us to
    # accept unquoted sentences as arguments.
    argument="$argument $arg"
  fi
done

# Check if input is piped; if so read it character for character. If not,
# see if argument supplied is a file and read it character for character.
# If neither of these are true, assume the argument is a string of text.
if [ -p /dev/stdin ]; then
  while IFS= read -rn1 character; do
    handle_character "$character"
  done
else
  # If no arguments are supplied, print help and exit
  if [ "${argument// }" = "" ]; then
    echo -e "$USAGE"
    exit 0
  fi
  if [ -f "$argument" ]; then
    while read -rn1 character; do
      handle_character "$character"
    done < <(cat "$argument")
  else
    # Last try: Assume this is a string
    while read -rn1 character; do
      handle_character "$character"
    done < <(echo "$argument")
  fi
fi

echo
