#!/usr/bin/env bash
# shellcheck disable=SC2034
set -e

# Colors
BLUE='\033[1;34m'
BROWN='\033[0;33m'
GREEN='\033[1;32m'
NC='\033[0m'
YELLOW='\033[1;33m'

# Defaults
OBFUSCATION_LO="10"
OBFUSCATION_MD="50"
OBFUSCATION_HI="100"
OBFUSCATION_CHANCE="$OBFUSCATION_MD"
OBFUSCATION_FT="fairytale"
OBFUSCATION_CP="cyberpunk"
OBFUSCATION_STYLE="default"
SETS_DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )/sets" && pwd )

USAGE="
${BROWN}Usage${NC}: $0 [ARGUMENTS] [FILE|STRING]
Add a little flair to your text by substituting visually similar characters for your ordinary a-z and A-Z characters.
There are three ways to input text:
  ${GREEN}1${NC}) Pipe text to this script
  ${GREEN}2${NC}) Supply a file as argument
  ${GREEN}3${NC}) Add word or words as arguments.

${BROWN}Arguments${NC}:
  [--lo|--md|--hi]    Level of obfuscation.
                      Defaults to 'md', medium.
  [--ft|--cp]         Obfuscation style, fairytale
                      or cyberpunk. If unset, defaults
                      to a kitchen sink mix of styles.
"
HELP="
${BROWN}Usage examples${NC}:
  Highly obfuscate text from a file on your filesystem:
  \$ ${BLUE}cat a_tale_of_two_cities.txt | bash/karakter --hi${NC}

  Generate a mildly elvish version of your name for an email signature:
  \$ ${BLUE}bash/karakter --md --ft John Doe${NC}
"

function handle_character() {
  character="$1"
  case "$character" in
    "")
      # Don’t ask me why, but spaces come through as ""
      echo -n " "
      ;;
    [a-zA-Z])
      # If a-z or A-Z, find an alternative character, but first test against
      # obfuscation chance to se if we should bail early
      random_number=$((RANDOM % 100))
      if [ "$random_number" -gt "$OBFUSCATION_CHANCE" ]; then
        echo -n "$character"
      else
        # Try to put the string from <character> variable into a temp variable
        temp_characters="${!character}"
        if [ -n "$temp_characters" ]; then
          # If we found a string of alternative characters, pick one at random and print
          special_character="${temp_characters:$((RANDOM % ${#temp_characters})):1}"
          echo -n "$special_character"
        else
          # If not, just print the original character
          echo -n "$character"
        fi
      fi
      ;;
    *)
      # This is one of the characters we don’t transform, just print it
      echo -n "$character"
      ;;
  esac
}

argument=""

# Handle args
for arg in "$@"; do
  if [ "$arg" = "--lo" ] || [ "$arg" = "--md" ] || [ "$arg" = "--hi" ]; then
    case "$arg" in
      "--lo")
        OBFUSCATION_CHANCE="$OBFUSCATION_LO"
        ;;
      "--md")
        OBFUSCATION_CHANCE="$OBFUSCATION_MD"
        ;;
      *)
        OBFUSCATION_CHANCE="$OBFUSCATION_HI"
        ;;
    esac
  elif [ "$arg" = "--cp" ] || [ "$arg" = "--ft" ]; then
    case "$arg" in
      "--cp")
        OBFUSCATION_STYLE="$OBFUSCATION_CP"
        ;;
      *)
        OBFUSCATION_STYLE="$OBFUSCATION_FT"
        ;;
    esac
  elif [ "$arg" = "help" ] || [ "$arg" = "--help" ] || [ "$arg" = "-h" ]; then
    echo -e "$USAGE$HELP"
    exit 0
  else
    # Adding this to existing string instead of simply setting it allows us to
    # accept unquoted sentences as arguments.
    argument="$argument $arg"
  fi
done

# Load the correct set of characters
case "$OBFUSCATION_STYLE" in
  "cyberpunk")
    # shellcheck source=/dev/null
    source "$SETS_DIR/cyberpunk.set"
    ;;
  "fairytale")
    # shellcheck source=/dev/null
    source "$SETS_DIR/fairytale.set"
    ;;
  *)
    # shellcheck source=/dev/null
    source "$SETS_DIR/default.set"
    ;;
esac

# Define stdin
if [ "$OSTYPE" = "linux-android" ]; then
  # Probably Termux?
  STDIN="/proc/self/fd/0"
else
  # This will work on macos at least
  STDIN="/dev/stdin"
fi

# Check if input is piped; if so read it character for character. If not,
# see if argument supplied is a file and read it character for character.
# If neither of these are true, assume the argument is a string of text.
if [ -p "$STDIN" ]; then
  while IFS= read -rn1 character; do
    handle_character "$character"
  done
else
  # If no arguments are supplied, print help and exit
  if [ "${argument// }" = "" ]; then
    echo -e "$USAGE"
    exit 0
  fi
  if [ -f "$argument" ]; then
    while read -rn1 character; do
      handle_character "$character"
    done < <(cat "$argument")
  else
    # Last try: Assume this is a string
    while read -rn1 character; do
      handle_character "$character"
    done < <(echo "$argument")
  fi
fi

echo
